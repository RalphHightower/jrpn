<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="description" content="API docs for the testIntOperations method from the SelfTests class, for the Dart programming language.">
  <title>testIntOperations method - SelfTests class - controller library - Dart API</title>


  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="../../static-assets/github.css">
  <link rel="stylesheet" href="../../static-assets/styles.css">
  <link rel="icon" href="../../static-assets/favicon.png">

  
</head>


<body data-base-href="../../"
      data-using-base-href="false">

<div id="overlay-under-drawer"></div>

<header id="title">
  <button id="sidenav-left-toggle" type="button">&nbsp;</button>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="../../index.html">jrpn</a></li>
    <li><a href="../../controller/controller-library.html">controller</a></li>
    <li><a href="../../controller/SelfTests-class.html">SelfTests</a></li>
    <li class="self-crumb">testIntOperations method</li>
  </ol>
  <div class="self-name">testIntOperations</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>

<main>


  <div id="dartdoc-sidebar-left" class="sidebar sidebar-offcanvas-left">
    <header id="header-search-sidebar" class="hidden-l">
  <form class="search-sidebar" role="search">
    <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>

<ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
  <li><a href="../../index.html">jrpn</a></li>
  <li><a href="../../controller/controller-library.html">controller</a></li>
  <li><a href="../../controller/SelfTests-class.html">SelfTests</a></li>
  <li class="self-crumb">testIntOperations method</li>
</ol>


    <h5>SelfTests class</h5>
    <ol>

    <li class="section-title"><a href="../../controller/SelfTests-class.html#constructors">Constructors</a></li>
    <li><a href="../../controller/SelfTests/SelfTests.html">SelfTests</a></li>


    <li class="section-title">
      <a href="../../controller/SelfTests-class.html#instance-properties">Properties</a>
    </li>
    <li><a href="../../controller/SelfTests/errorsSeen.html">errorsSeen</a></li>
    <li class="inherited"><a href="https://api.flutter.dev/flutter/dart-core/Object/hashCode.html">hashCode</a></li>
    <li><a href="../../controller/SelfTests/inCalculator.html">inCalculator</a></li>
    <li class="inherited"><a href="https://api.flutter.dev/flutter/dart-core/Object/runtimeType.html">runtimeType</a></li>
    <li><a href="../../controller/SelfTests/testsRun.html">testsRun</a></li>

    <li class="section-title"><a href="../../controller/SelfTests-class.html#instance-methods">Methods</a></li>
    <li><a href="../../controller/SelfTests/fd.html">fd</a></li>
    <li class="inherited"><a href="https://api.flutter.dev/flutter/dart-core/Object/noSuchMethod.html">noSuchMethod</a></li>
    <li><a href="../../controller/SelfTests/runAll.html">runAll</a></li>
    <li><a href="../../controller/SelfTests/testFloatConvert.html">testFloatConvert</a></li>
    <li><a href="../../controller/SelfTests/testFloatValues.html">testFloatValues</a></li>
    <li><a href="../../controller/SelfTests/testIntOperations.html">testIntOperations</a></li>
    <li><a href="../../controller/SelfTests/testIntValues.html">testIntValues</a></li>
    <li><a href="../../controller/SelfTests/testJson.html">testJson</a></li>
    <li><a href="../../controller/SelfTests/testNumbers.html">testNumbers</a></li>
    <li class="inherited"><a href="https://api.flutter.dev/flutter/dart-core/Object/toString.html">toString</a></li>

    <li class="section-title inherited"><a href="../../controller/SelfTests-class.html#operators">Operators</a></li>
    <li class="inherited"><a href="https://api.flutter.dev/flutter/dart-core/Object/operator_equals.html">operator ==</a></li>




</ol>

  </div><!--/.sidebar-offcanvas-->

  <div id="dartdoc-main-content" class="main-content">
      <div>
<h1><span class="kind-method">testIntOperations</span> method 
    <a href="https://dart.dev/null-safety" class="feature feature-null-safety" title="Supports the null safety language feature.">Null safety</a>
</h1></div>

    <section class="multi-line-signature">
      

<span class="returntype"><a href="https://api.flutter.dev/flutter/dart-async/Future-class.html">Future</a><span class="signature">&lt;<wbr><span class="type-parameter">void</span>&gt;</span></span>
<span class="name ">testIntOperations</span>(<wbr>)

      

    </section>
    


    
<section class="summary source-code" id="source">
  <h2><span>Implementation</span></h2>
  <pre class="language-dart"><code class="language-dart">Future&lt;void&gt; testIntOperations() async {
  await _test(&quot;2&#39;s complement int operations&quot;, () async {
    Model m = Model();
    m.wordSize = 16;
    m.displayMode = DisplayMode.decimal;
    m.integerSignMode = SignMode.twosComplement;

    &#47;&#47; -1 + 1 = 0, set carry
    m.cFlag = false;
    m.yI = BigInt.from(-1);
    m.xI = BigInt.from(1);
    Operations.plus.intCalc!(m);
    await _expect(m.xI, BigInt.zero);
    await _expect(m.cFlag, true);

    &#47;&#47; 0 + 1 = 1, clear carry
    m.cFlag = true;
    m.yI = BigInt.from(0);
    m.xI = BigInt.from(1);
    Operations.plus.intCalc!(m);
    await _expect(m.xI, BigInt.one);
    await _expect(m.cFlag, false);

    &#47;&#47; 32767 * 2 = 32766, set overflow
    m.gFlag = false;
    m.yI = BigInt.from(32767);
    m.xI = BigInt.from(2);
    Operations.mult.intCalc!(m);
    await _expect(m.xI, BigInt.from(32766));
    await _expect(m.gFlag, true);

    &#47;&#47; 1440 &#47; -12 = -120, clear carry
    m.cFlag = true;
    m.yI = BigInt.from(1440);
    m.xI = BigInt.from(-12);
    Operations.div.intCalc!(m);
    await _expect(m.xI, BigInt.from(-120));
    await _expect(m.cFlag, false);
  });

  await _test(&quot;1&#39;s complement int operations&quot;, () async {
    Model m = Model();
    m.wordSize = 16;
    m.integerSignMode = SignMode.onesComplement;
    m.wordSize = 4;

    &#47;&#47; -1 + -1 = -2, set carry
    m.cFlag = true;
    m.yI = BigInt.from(-1);
    m.xI = BigInt.from(-1);
    Operations.plus.intCalc!(m);
    await _expect(m.xI, BigInt.from(-2));
    await _expect(m.cFlag, true);

    &#47;&#47; 3 - 4 = -1, set borrow (that is, cFlag)
    m.cFlag = false;
    m.yI = BigInt.from(3);
    m.xI = BigInt.from(4);
    Operations.minus.intCalc!(m);
    await _expect(m.xI, BigInt.from(-1));
    await _expect(m.cFlag, true);

    &#47;&#47; -3 + 3 = 0, no carry
    m.cFlag = true;
    m.yI = BigInt.from(-3);
    m.xI = BigInt.from(3);
    Operations.plus.intCalc!(m);
    await _expect(m.xI, BigInt.from(0));
    await _expect(m.cFlag, false);

    &#47;&#47; 6 - 5 = 1, no borrow
    m.cFlag = true;
    m.yI = BigInt.from(6);
    m.xI = BigInt.from(5);
    Operations.minus.intCalc!(m);
    await _expect(m.xI, BigInt.from(1));
    await _expect(m.cFlag, false);
  });

  await _test(&quot;subtraction carry, 1&#39;s and 2&#39;s complement&quot;, () async {
    Model m = Model();
    m.wordSize = 4;
    for (final c in [SignMode.onesComplement, SignMode.twosComplement]) {
      m.integerSignMode = c;

      &#47;&#47; -6 - -4 = -2, carry set
      m.cFlag = false;
      m.yI = BigInt.from(-6);
      m.xI = BigInt.from(-4);
      Operations.minus.intCalc!(m);
      await _expect(m.xI, BigInt.from(-2));
      await _expect(m.cFlag, true);

      &#47;&#47; 6 - 1 = 5, carry cleared
      m.cFlag = true;
      m.yI = BigInt.from(6);
      m.xI = BigInt.from(1);
      Operations.minus.intCalc!(m);
      await _expect(m.xI, BigInt.from(5));
      await _expect(m.cFlag, false);
    }
  });
  await _test(&quot;2&#39;s complement range&quot;, () async {
    Model m = Model();
    m.wordSize = 4;

    &#47;&#47; 7 + 6 = -3, G set, C cleared
    m.cFlag = true;
    m.gFlag = false;
    m.yI = BigInt.from(7);
    m.xI = BigInt.from(6);
    Operations.plus.intCalc!(m);
    await _expect(m.xI, BigInt.from(-3));
    await _expect(m.cFlag, false);
    await _expect(m.gFlag, true);
  });

  await _test(&#39;int rmd&#39;, () async {
    Model m = Model();
    m.yI = BigInt.from(0x66);
    m.xI = BigInt.from(7);
    Operations.div.intCalc!(m);
    await _expect(m.xI, BigInt.from(0xe));
    m.pushStack();
    m.xI = BigInt.from(2);
    Operations.div.intCalc!(m);
    await _expect(m.xI, BigInt.from(0x7));
    m.pushStack();
    m.xI = BigInt.from(4);
    Operations.rmd.intCalc!(m);
    await _expect(m.xI, BigInt.from(0x3));
  });
  await _test(&#39;logical operations&#39;, () async {
    &#47;&#47; Not
    Model m = Model();
    await _expect(m.wordSize, 16); &#47;&#47; default
    m.displayMode = DisplayMode.bin;
    m.x = m.tryParseValue(&#39;11111111&#39;)!;
    Operations.not.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;1111111100000000&#39;));

    &#47;&#47; and
    m.y = m.tryParseValue(&#39;10101&#39;)!;
    m.x = m.tryParseValue(&#39;10011&#39;)!;
    Operations.and.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;10001&#39;));

    &#47;&#47; or
    m.y = m.tryParseValue(&#39;10101&#39;)!;
    m.x = m.tryParseValue(&#39;10011&#39;)!;
    Operations.or.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;10111&#39;));

    &#47;&#47; xor
    m.y = m.tryParseValue(&#39;1010101&#39;)!;
    m.x = m.tryParseValue(&#39;1011101&#39;)!;
    Operations.xor.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;1000&#39;));

    &#47;&#47; sl (shift left)
    m.wordSize = 8;
    m.x = m.tryParseValue(&#39;10011100&#39;)!;
    Operations.sl.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;00111000&#39;));
    await _expect(m.cFlag, true);
    Operations.sl.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;01110000&#39;));
    await _expect(m.cFlag, false);

    &#47;&#47; sr (shift right)
    Operations.sr.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;00111000&#39;));
    await _expect(m.cFlag, false);
    Operations.sr.intCalc!(m);
    await _expect(m.cFlag, false);
    Operations.sr.intCalc!(m);
    await _expect(m.cFlag, false);
    Operations.sr.intCalc!(m);
    await _expect(m.cFlag, false);
    Operations.sr.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;00000011&#39;));
    await _expect(m.cFlag, true);

    &#47;&#47; lj (left justify)
    m.xI = BigInt.from(0);
    Operations.lj.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;0&#39;));
    await _expect(m.y, m.tryParseValue(&#39;0&#39;));
    m.x = m.tryParseValue(&#39;1111&#39;)!;
    Operations.lj.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;100&#39;));
    await _expect(m.y, m.tryParseValue(&#39;11110000&#39;));

    &#47;&#47; asr
    m.integerSignMode = SignMode.unsigned;
    m.x = m.tryParseValue(&#39;10011100&#39;)!;
    Operations.asr.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;01001110&#39;));
    m.integerSignMode = SignMode.twosComplement;
    m.x = m.tryParseValue(&#39;10011100&#39;)!;
    Operations.asr.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;11001110&#39;));

    &#47;&#47; rl
    m.x = m.tryParseValue(&#39;10011100&#39;)!;
    m.cFlag = false;
    Operations.rl.intCalc!(m);
    await _expect(m.cFlag, true);
    await _expect(m.x, m.tryParseValue(&#39;00111001&#39;));
    Operations.rl.intCalc!(m);
    await _expect(m.cFlag, false);
    await _expect(m.x, m.tryParseValue(&#39;01110010&#39;));

    &#47;&#47; rr
    Operations.rr.intCalc!(m);
    await _expect(m.cFlag, false);
    await _expect(m.x, m.tryParseValue(&#39;00111001&#39;));
    Operations.rr.intCalc!(m);
    await _expect(m.cFlag, true);
    await _expect(m.x, m.tryParseValue(&#39;10011100&#39;));
    Operations.rr.intCalc!(m);
    await _expect(m.cFlag, false);
    await _expect(m.x, m.tryParseValue(&#39;01001110&#39;));

    &#47;&#47; rlc
    m.x = m.tryParseValue(&#39;10011100&#39;)!;
    m.cFlag = false;
    Operations.rlc.intCalc!(m);
    await _expect(m.cFlag, true);
    await _expect(m.x, m.tryParseValue(&#39;00111000&#39;));
    Operations.rlc.intCalc!(m);
    await _expect(m.cFlag, false);
    await _expect(m.x, m.tryParseValue(&#39;01110001&#39;));

    &#47;&#47; rrc
    Operations.rrc.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;00111000&#39;));
    m.cFlag = true;
    Operations.rrc.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;10011100&#39;));
    await _expect(m.cFlag, false);
    Operations.rrc.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;01001110&#39;));
    await _expect(m.cFlag, false);

    &#47;&#47; rln
    m.x = m.tryParseValue(&#39;10011100&#39;)!;
    m.pushStack();
    m.xI = BigInt.one;
    m.cFlag = false;
    Operations.rln.intCalc!(m);
    await _expect(m.cFlag, true);
    await _expect(m.x, m.tryParseValue(&#39;00111001&#39;));

    m.x = m.tryParseValue(&#39;10011100&#39;)!;
    m.pushStack();
    m.xI = BigInt.two;
    m.cFlag = true;
    Operations.rln.intCalc!(m);
    await _expect(m.cFlag, false);
    await _expect(m.x, m.tryParseValue(&#39;01110010&#39;));

    &#47;&#47; rrn
    m.x = m.tryParseValue(&#39;01110010&#39;)!;
    m.pushStack();
    m.xI = BigInt.one;
    Operations.rrn.intCalc!(m);
    await _expect(m.cFlag, false);
    await _expect(m.x, m.tryParseValue(&#39;00111001&#39;));

    m.x = m.tryParseValue(&#39;01110010&#39;)!;
    m.pushStack();
    m.xI = BigInt.two;
    Operations.rrn.intCalc!(m);
    await _expect(m.cFlag, true);
    await _expect(m.x, m.tryParseValue(&#39;10011100&#39;));

    m.x = m.tryParseValue(&#39;01110010&#39;)!;
    m.pushStack();
    m.xI = BigInt.from(3);
    Operations.rrn.intCalc!(m);
    await _expect(m.cFlag, false);
    await _expect(m.x, m.tryParseValue(&#39;01001110&#39;));

    &#47;&#47; rlcn
    m.x = m.tryParseValue(&#39;10011100&#39;)!;
    m.cFlag = false;
    m.pushStack();
    m.xI = BigInt.one;
    Operations.rlcn.intCalc!(m);
    await _expect(m.cFlag, true);
    await _expect(m.x, m.tryParseValue(&#39;00111000&#39;));

    m.x = m.tryParseValue(&#39;10011100&#39;)!;
    m.cFlag = false;
    m.pushStack();
    m.xI = BigInt.two;
    Operations.rlcn.intCalc!(m);
    await _expect(m.cFlag, false);
    await _expect(m.x, m.tryParseValue(&#39;01110001&#39;));

    &#47;&#47; rrcn
    m.x = m.tryParseValue(&#39;01110001&#39;)!;
    m.cFlag = false;
    m.pushStack();
    m.xI = BigInt.one;
    Operations.rrcn.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;00111000&#39;));
    await _expect(m.cFlag, true);

    m.x = m.tryParseValue(&#39;01110001&#39;)!;
    m.cFlag = false;
    m.pushStack();
    m.xI = BigInt.two;
    Operations.rrcn.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;10011100&#39;));
    await _expect(m.cFlag, false);

    m.x = m.tryParseValue(&#39;01110001&#39;)!;
    m.cFlag = false;
    m.pushStack();
    m.xI = BigInt.from(3);
    Operations.rrcn.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;01001110&#39;));
    await _expect(m.cFlag, false);

    &#47;&#47; cb
    m.y = m.tryParseValue(&#39;11111111&#39;)!;
    m.x = m.tryParseValue(&#39;00000011&#39;)!;
    Operations.cb.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;11110111&#39;));

    &#47;&#47; sb
    m.y = m.tryParseValue(&#39;01110000&#39;)!;
    m.x = m.tryParseValue(&#39;00000000&#39;)!;
    Operations.sb.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;01110001&#39;));

    m.pushStack();
    m.xI = BigInt.from(7);
    Operations.sb.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;11110001&#39;));

    &#47;&#47; maskr
    m.xI = BigInt.from(4);
    Operations.maskr.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;00001111&#39;));
    m.xI = BigInt.from(0);
    Operations.maskr.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;00000000&#39;));
    m.xI = BigInt.from(8);
    Operations.maskr.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;11111111&#39;));

    &#47;&#47; maskl
    m.xI = BigInt.from(3);
    Operations.maskl.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;11100000&#39;));
    m.xI = BigInt.from(0);
    Operations.maskl.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;00000000&#39;));
    m.xI = BigInt.from(7);
    Operations.maskl.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;11111110&#39;));
    m.xI = BigInt.from(8);
    Operations.maskl.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;11111111&#39;));

    &#47;&#47; #b
    m.x = m.tryParseValue(&#39;01011101&#39;)!;
    Operations.poundB.intCalc!(m);
    await _expect(m.xI, BigInt.from(5));
    m.x = m.tryParseValue(&#39;00000000&#39;)!;
    Operations.poundB.intCalc!(m);
    await _expect(m.xI, BigInt.from(0));
    m.x = m.tryParseValue(&#39;11111111&#39;)!;
    Operations.poundB.intCalc!(m);
    await _expect(m.xI, BigInt.from(8));
  });
  await _test(&#39;double operations&#39;, () async {
    Model m = Model();
    m.wordSize = 5;
    await _expect(m.signMode, SignMode.twosComplement); &#47;&#47; default
    m.displayMode = DisplayMode.bin;

    &#47;&#47; double multiply:  7*6 = 42
    m.y = m.tryParseValue(&#39;00111&#39;)!;
    m.x = m.tryParseValue(&#39;00110&#39;)!;
    Operations.dblx.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;00001&#39;));
    await _expect(m.y, m.tryParseValue(&#39;01010&#39;));

    &#47;&#47; double divide:  -88 &#47; 11
    m.x = m.tryParseValue(&#39;01000&#39;)!; &#47;&#47; Z
    m.pushStack();
    m.x = m.tryParseValue(&#39;11101&#39;)!; &#47;&#47; Y, YZ is -88
    m.pushStack();
    m.x = m.tryParseValue(&#39;01011&#39;)!; &#47;&#47; X, 11
    Operations.dblDiv.intCalc!(m);
    await _expect(m.x, m.tryParseValue(&#39;11000&#39;));

    &#47;&#47; double remainder: -87 remainder 11 = -10
    m.x = m.tryParseValue(&#39;01001&#39;)!; &#47;&#47; Z
    m.pushStack();
    m.x = m.tryParseValue(&#39;11101&#39;)!; &#47;&#47; Y, YZ is -87
    m.pushStack();
    m.x = m.tryParseValue(&#39;01011&#39;)!; &#47;&#47; X, 11
    Operations.dblr.intCalc!(m);
    await _expect(m.xI, BigInt.from(-10));

    &#47;&#47; double multiply:  Unsigned f723eb313f123827 * a20175becabcde06
    &#47;&#47;          is 9c6623a4aff98347_8e11697b49c322ea
    m.wordSize = 64;
    m.integerSignMode = SignMode.unsigned;
    m.gFlag = true;
    m.xI = BigInt.parse(&#39;f723eb313f123827&#39;, radix: 16);
    m.yI = BigInt.parse(&#39;a20175becabcde06&#39;, radix: 16);
    Operations.dblx.intCalc!(m);
    await _expect(m.xI, BigInt.parse(&#39;9c6623a4aff98347&#39;, radix: 16));
    await _expect(m.yI, BigInt.parse(&#39;8e11697b49c322ea&#39;, radix: 16));
    await _expect(m.gFlag, false);

    &#47;&#47; double divide with above numbers
    m.pushStack();
    m.xI = BigInt.parse(&#39;a20175becabcde06&#39;, radix: 16);
    Operations.dblDiv.intCalc!(m);
    await _expect(m.xI, BigInt.parse(&#39;f723eb313f123827&#39;, radix: 16));

    &#47;&#47; double remainder with big numbers
    m.xI = BigInt.parse(&#39;8e11697b49c322ec&#39;, radix: 16);
    m.pushStack();
    m.xI = BigInt.parse(&#39;9c6623a4aff98347&#39;, radix: 16);
    m.pushStack();
    m.xI = BigInt.parse(&#39;f723eb313f123827&#39;, radix: 16);
    Operations.dblr.intCalc!(m);
    await _expect(m.xI, BigInt.from(2));
  });
  await _test(&#39;Unsigned add and subtract&#39;, _testUnsigned);
}</code></pre>
</section>


  </div> <!-- /.main-content -->

  <div id="dartdoc-sidebar-right" class="sidebar sidebar-offcanvas-right">
  </div><!--/.sidebar-offcanvas-->

</main>

<footer>
  <span class="no-break">
    jrpn
      2.0.0+3
  </span>

  
</footer>


<script src="../../static-assets/highlight.pack.js"></script>
<script src="../../static-assets/script.js"></script>



</body>

</html>

